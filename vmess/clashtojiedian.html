<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>èŠ‚ç‚¹è½¬æ¢å·¥å…· - Node to Clash Converter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .main-content {
            padding: 40px;
        }

        .converter-section {
            display: grid;
            grid-template-columns: 1fr 80px 1fr;
            gap: 20px;
            align-items: start;
        }

        .input-section, .output-section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 25px;
            border: 2px solid #e9ecef;
            transition: border-color 0.3s ease;
        }

        .input-section:focus-within, .output-section:focus-within {
            border-color: #4facfe;
        }

        .section-title {
            font-size: 1.3em;
            font-weight: 600;
            margin-bottom: 15px;
            color: #333;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .protocol-selector {
            margin-bottom: 20px;
        }

        .protocol-selector label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #555;
        }

        .protocol-selector select {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            background: white;
            transition: border-color 0.3s ease;
        }

        .protocol-selector select:focus {
            outline: none;
            border-color: #4facfe;
        }

        .input-area, .output-area {
            width: 100%;
            min-height: 300px;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            resize: vertical;
            transition: border-color 0.3s ease;
        }

        .input-area:focus, .output-area:focus {
            outline: none;
            border-color: #4facfe;
        }

        .output-area {
            background: #f8f9fa;
            color: #333;
        }

        .convert-button-container {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 15px;
        }

        .convert-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 20px;
            border-radius: 50px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            min-width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .convert-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .convert-btn:active {
            transform: translateY(0);
        }

        .supported-protocols {
            margin-top: 30px;
            padding: 25px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 4px solid #4facfe;
        }

        .supported-protocols h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .protocol-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .protocol-tag {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 500;
        }

        .copy-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 10px;
            transition: background 0.3s ease;
        }

        .copy-btn:hover {
            background: #218838;
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 12px;
            border-radius: 5px;
            margin-top: 10px;
            border: 1px solid #f5c6cb;
        }

        .success-message {
            background: #d4edda;
            color: #155724;
            padding: 12px;
            border-radius: 5px;
            margin-top: 10px;
            border: 1px solid #c3e6cb;
        }

        @media (max-width: 768px) {
            .converter-section {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .convert-button-container {
                flex-direction: row;
                justify-content: center;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .main-content {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸš€ èŠ‚ç‚¹è½¬æ¢å·¥å…·</h1>
            <p>æ”¯æŒå¤šç§åè®®çš„åŒå‘è½¬æ¢ - Node â‡„ Clash Config</p>
        </div>
        
        <div class="main-content">
            <div class="converter-section">
                <div class="input-section">
                    <div class="section-title">
                        ğŸ“¥ è¾“å…¥åŒºåŸŸ
                    </div>
                    <div class="protocol-selector">
                        <label for="inputType">è¾“å…¥ç±»å‹:</label>
                        <select id="inputType">
                            <option value="node">èŠ‚ç‚¹é“¾æ¥</option>
                            <option value="clash">Clash é…ç½®</option>
                        </select>
                    </div>
                    <textarea id="inputArea" class="input-area" placeholder="è¯·è¾“å…¥èŠ‚ç‚¹é“¾æ¥æˆ–Clashé…ç½®å†…å®¹..."></textarea>
                    <div id="inputError" class="error-message" style="display: none;"></div>
                </div>
                
                <div class="convert-button-container">
                    <button id="convertBtn" class="convert-btn" title="è½¬æ¢">
                        â‡„
                    </button>
                </div>
                
                <div class="output-section">
                    <div class="section-title">
                        ğŸ“¤ è¾“å‡ºåŒºåŸŸ
                    </div>
                    <div class="protocol-selector">
                        <label for="outputType">è¾“å‡ºç±»å‹:</label>
                        <select id="outputType">
                            <option value="clash">Clash é…ç½®</option>
                            <option value="node">èŠ‚ç‚¹é“¾æ¥</option>
                        </select>
                    </div>
                    <textarea id="outputArea" class="output-area" readonly placeholder="è½¬æ¢ç»“æœå°†æ˜¾ç¤ºåœ¨è¿™é‡Œ..."></textarea>
                    <button id="copyBtn" class="copy-btn" style="display: none;">ğŸ“‹ å¤åˆ¶ç»“æœ</button>
                    <div id="outputSuccess" class="success-message" style="display: none;"></div>
                </div>
            </div>
            
            <div class="supported-protocols">
                <h3>ğŸ”§ æ”¯æŒçš„åè®®</h3>
                <div class="protocol-list">
                    <span class="protocol-tag">Shadowsocks</span>
                    <span class="protocol-tag">ShadowsocksR</span>
                    <span class="protocol-tag">SOCKS5</span>
                    <span class="protocol-tag">HTTP</span>
                    <span class="protocol-tag">VMess</span>
                    <span class="protocol-tag">Trojan</span>
                    <span class="protocol-tag">VLESS</span>
                    <span class="protocol-tag">Hysteria</span>
                    <span class="protocol-tag">Hysteria2</span>
                    <span class="protocol-tag">Telegram</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // åè®®è§£æå™¨
        class ProtocolParser {
            // è§£æShadowsocksé“¾æ¥
            static parseShadowsocks(url) {
                // å¤„ç†æ ‡å‡†SSæ ¼å¼: ss://method:password@server:port#name
                let match = url.match(/^ss:\/\/([^@]+)@([^:]+):(\d+)(?:#(.+))?$/);
                if (match) {
                    const [, auth, server, port, name] = match;
                    try {
                        const decoded = atob(auth);
                        const [method, password] = decoded.split(':');
                        
                        return {
                            name: name ? decodeURIComponent(name) : 'Shadowsocks',
                            type: 'ss',
                            server,
                            port: parseInt(port),
                            cipher: method,
                            password
                        };
                    } catch (e) {
                        return null;
                    }
                }
                
                // å¤„ç†å¦ä¸€ç§SSæ ¼å¼: ss://base64(method:password@server:port)#name
                match = url.match(/^ss:\/\/([^#]+)#(.+)$/);
                if (match) {
                    const [, mainPart, name] = match;
                    try {
                        const decoded = atob(mainPart);
                        const parts = decoded.split('@');
                        if (parts.length === 2) {
                            const [methodPassword, serverPort] = parts;
                            const [method, password] = methodPassword.split(':');
                            const [server, port] = serverPort.split(':');
                            
                            return {
                                name: decodeURIComponent(name),
                                type: 'ss',
                                server,
                                port: parseInt(port),
                                cipher: method,
                                password
                            };
                        }
                    } catch (e) {
                        return null;
                    }
                }
                
                return null;
            }
            
            // è§£æSSRé“¾æ¥
            static parseSsr(url) {
                try {
                    const data = url.replace('ssr://', '');
                    const decoded = atob(data);
                    const parts = decoded.split('/');
                    const serverInfo = parts[0];
                    const [server, port, protocol, method, obfs, passwordB64] = serverInfo.split(':');
                    const password = atob(passwordB64.replace(/_/g, '/').replace(/-/g, '+'));
                    
                    // è§£æå‚æ•°
                    const params = new URLSearchParams(parts[1] || '');
                    const name = params.get('remarks') ? atob(params.get('remarks')) : 'SSR';
                    
                    return {
                        name: name,
                        type: 'ssr',
                        server,
                        port: parseInt(port),
                        protocol,
                        cipher: method,
                        obfs,
                        password
                    };
                } catch (e) {
                    return null;
                }
            }
            
            // è§£æHysteriaé“¾æ¥
            static parseHysteria(url) {
                const match = url.match(/^hysteria:\/\/([^:]+):(\d+)\?(.+)#(.+)$/);
                if (!match) return null;
                
                const [, server, port, params, name] = match;
                const urlParams = new URLSearchParams(params);
                
                return {
                    name: decodeURIComponent(name),
                    type: 'hysteria',
                    server,
                    port: parseInt(port),
                    auth_str: urlParams.get('auth') || '',
                    protocol: urlParams.get('protocol') || 'udp',
                    up: parseInt(urlParams.get('upmbps')) || 50,
                    down: parseInt(urlParams.get('downmbps')) || 250,
                    alpn: urlParams.get('alpn') || 'h3',
                    sni: urlParams.get('peer') || server,
                    'skip-cert-verify': urlParams.get('insecure') === '1'
                };
            }
            
            // è§£æHysteria2é“¾æ¥
            static parseHysteria2(url) {
                const match = url.match(/^hysteria2:\/\/([^@]+)@([^:]+):(\d+)\?(.+)#(.+)$/);
                if (!match) return null;
                
                const [, auth, server, port, params, name] = match;
                const urlParams = new URLSearchParams(params);
                
                return {
                    name: decodeURIComponent(name),
                    type: 'hysteria2',
                    server,
                    port: parseInt(port),
                    password: auth,
                    sni: urlParams.get('sni') || server,
                    'skip-cert-verify': urlParams.get('insecure') === '1',
                    mport: urlParams.get('mport') || '',
                    udp: true
                };
            }
            
            // è§£æTelegramé“¾æ¥
            static parseTelegram(url) {
                const match = url.match(/https:\/\/t\.me\/socks\?server=([^&]+)&port=(\d+)&user=([^&]+)&pass=([^&]+)/);
                if (!match) return null;
                
                const [, server, port, username, password] = match;
                
                return {
                    name: 'telegram_proxy',
                    type: 'socks5',
                    server,
                    port: parseInt(port),
                    username,
                    password
                };
            }
            
            // è§£æVMessé“¾æ¥
            static parseVmess(url) {
                // å¤„ç†Shadowrocketæ ¼å¼çš„base64ç¼–ç 
                if (url.includes('?remarks=') || url.includes('&remarks=')) {
                    try {
                        const parts = url.split('://');
                        if (parts.length !== 2) return null;
                        
                        const decoded = atob(parts[1].split('?')[0]);
                        const [userInfo, serverInfo] = decoded.split('@');
                        const [server, port] = serverInfo.split(':');
                        
                        const urlObj = new URL(url);
                        const params = urlObj.searchParams;
                        
                        // å¤„ç†UUIDï¼Œå¯èƒ½åŒ…å«methodå‰ç¼€
                        let uuid = userInfo;
                        if (userInfo.includes(':')) {
                            uuid = userInfo.split(':')[1] || userInfo.split(':')[0];
                        }
                        
                        return {
                            name: params.get('remarks') ? decodeURIComponent(params.get('remarks')) : 'VMess',
                            type: 'vmess',
                            server,
                            port: parseInt(port),
                            uuid: uuid,
                            alterId: parseInt(params.get('alterId')) || 0,
                            cipher: params.get('cipher') || 'auto',
                            network: params.get('obfs') === 'websocket' ? 'ws' : (params.get('obfs') === 'http' ? 'http' : 'tcp'),
                            tls: params.get('tls') === '1' || params.get('security') === 'tls',
                            'ws-opts': params.get('obfs') === 'websocket' ? {
                                path: params.get('path') || '/'
                            } : undefined,
                            'http-opts': params.get('obfs') === 'http' ? {
                                path: [params.get('path') || '/']
                            } : undefined,
                            'skip-cert-verify': true
                        };
                    } catch (e) {
                        // å¦‚æœbase64è§£ç å¤±è´¥ï¼Œå°è¯•æ ‡å‡†æ ¼å¼
                    }
                }
                
                // æ ‡å‡†VMessæ ¼å¼
                try {
                    const data = JSON.parse(atob(url.replace('vmess://', '')));
                    return {
                        name: data.ps || 'VMess',
                        type: 'vmess',
                        server: data.add,
                        port: parseInt(data.port),
                        uuid: data.id,
                        alterId: parseInt(data.aid) || 0,
                        cipher: data.scy || 'auto',
                        network: data.net || 'tcp',
                        tls: data.tls === 'tls',
                        'ws-opts': data.net === 'ws' ? {
                            path: data.path || '/',
                            headers: data.host ? { Host: data.host } : {}
                        } : undefined,
                        'skip-cert-verify': true
                    };
                } catch (e) {
                    return null;
                }
            }
            
            // è§£æTrojané“¾æ¥
            static parseTrojan(url) {
                const match = url.match(/^trojan:\/\/([^@]+)@([^:]+):(\d+)(?:\?([^#]+))?(?:#(.+))?$/);
                if (!match) return null;
                
                const [, password, server, port, params, name] = match;
                const urlParams = new URLSearchParams(params || '');
                
                return {
                    name: name ? decodeURIComponent(name) : 'Trojan',
                    type: 'trojan',
                    server,
                    port: parseInt(port),
                    password,
                    sni: urlParams.get('sni') || server,
                    'skip-cert-verify': urlParams.get('allowInsecure') === '1'
                };
            }
            
            // è§£æVLESSé“¾æ¥
            static parseVless(url) {
                // å¤„ç†Shadowrocketæ ¼å¼çš„base64ç¼–ç 
                if (url.includes('?remarks=') || url.includes('&remarks=')) {
                    try {
                        const parts = url.split('://');
                        if (parts.length !== 2) return null;
                        
                        const decoded = atob(parts[1].split('?')[0]);
                        const [userInfo, serverInfo] = decoded.split('@');
                        const [server, port] = serverInfo.split(':');
                        
                        const urlObj = new URL(url);
                        const params = urlObj.searchParams;
                        
                        // å¤„ç†UUIDï¼Œå¯èƒ½åŒ…å«methodå‰ç¼€
                        let uuid = userInfo;
                        if (userInfo.includes(':')) {
                            uuid = userInfo.split(':')[1] || userInfo.split(':')[0];
                        }
                        
                        return {
                            name: params.get('remarks') ? decodeURIComponent(params.get('remarks')) : 'VLESS',
                            type: 'vless',
                            server,
                            port: parseInt(port),
                            uuid: uuid,
                            flow: params.get('flow') || '',
                            network: params.get('obfs') === 'websocket' ? 'ws' : (params.get('type') || 'tcp'),
                            tls: params.get('tls') === '1' || params.get('security') === 'tls' || parseInt(port) === 443,
                            'ws-opts': params.get('obfs') === 'websocket' ? {
                                path: params.get('path') || '/'
                            } : undefined,
                            'skip-cert-verify': true
                        };
                    } catch (e) {
                        // å¦‚æœbase64è§£ç å¤±è´¥ï¼Œå°è¯•æ ‡å‡†æ ¼å¼
                    }
                }
                
                // æ ‡å‡†VLESSæ ¼å¼
                const match = url.match(/^vless:\/\/([^@]+)@([^:]+):(\d+)(?:\?([^#]+))?(?:#(.+))?$/);
                if (!match) return null;
                
                const [, uuid, server, port, params, name] = match;
                const urlParams = new URLSearchParams(params || '');
                
                return {
                    name: name ? decodeURIComponent(name) : 'VLESS',
                    type: 'vless',
                    server,
                    port: parseInt(port),
                    uuid,
                    flow: urlParams.get('flow') || '',
                    network: urlParams.get('type') || 'tcp',
                    tls: urlParams.get('security') === 'tls',
                    'skip-cert-verify': true
                };
            }
            
            // è§£æSOCKS5é“¾æ¥
            static parseSocks5(url) {
                const match = url.match(/^socks5:\/\/(?:([^:]+):([^@]+)@)?([^:]+):(\d+)(?:#(.+))?$/);
                if (!match) return null;
                
                const [, username, password, server, port, name] = match;
                
                return {
                    name: name ? decodeURIComponent(name) : 'SOCKS5',
                    type: 'socks5',
                    server,
                    port: parseInt(port),
                    username: username || '',
                    password: password || ''
                };
            }
            
            // è§£æHTTPé“¾æ¥
            static parseHttp(url) {
                // å¤„ç†åå¼•å·åŒ…å›´çš„é“¾æ¥
                const cleanUrl = url.replace(/`/g, '');
                const match = cleanUrl.match(/^https?:\/\/(?:([^:]+):([^@]+)@)?([^:]+):(\d+)(?:#(.+))?$/);
                if (!match) return null;
                
                const [, username, password, server, port, name] = match;
                
                return {
                    name: name ? decodeURIComponent(name) : 'http_proxy',
                    type: 'http',
                    server,
                    port: parseInt(port),
                    username: username || '',
                    password: password || ''
                };
            }
        }
        
        // Clashé…ç½®ç”Ÿæˆå™¨
        class ClashGenerator {
            static generateConfig(proxies) {
                const proxyNames = proxies.map(p => p.name);
                
                const config = {
                    'mixed-port': 7890,
                    'allow-lan': true,
                    mode: 'Rule',
                    'log-level': 'info',
                    'external-controller': '0.0.0.0:9090',
                    dns: {
                        enabled: true,
                        nameserver: [
                            '119.29.29.29',
                            '223.5.5.5'
                        ],
                        fallback: [
                            '8.8.8.8',
                            '8.8.4.4',
                            'tls://1.0.0.1:853',
                            'tls://dns.google:853'
                        ]
                    },
                    proxies: proxies,
                    'proxy-groups': [
                        {
                            name: 'ğŸš€ èŠ‚ç‚¹é€‰æ‹©',
                            type: 'select',
                            proxies: ['â™»ï¸ è‡ªåŠ¨é€‰æ‹©', 'ğŸ¯ å…¨çƒç›´è¿', 'ğŸ‡­ğŸ‡° é¦™æ¸¯èŠ‚ç‚¹', 'ğŸ‡¯ğŸ‡µ æ—¥æœ¬èŠ‚ç‚¹', 'ğŸ‡ºğŸ‡² ç¾å›½èŠ‚ç‚¹', 'ğŸ‡¸ğŸ‡¬ ç‹®åŸèŠ‚ç‚¹', 'ğŸ‡°ğŸ‡· éŸ©å›½èŠ‚ç‚¹', 'ğŸš© å…¶å®ƒèŠ‚ç‚¹']
                        },
                        {
                            name: 'â™»ï¸ è‡ªåŠ¨é€‰æ‹©',
                            type: 'url-test',
                            proxies: proxyNames,
                            url: 'http://www.gstatic.com/generate_204',
                            interval: 300,
                            tolerance: 50
                        },
                        {
                            name: 'ğŸ›‘ å…¨çƒæ‹¦æˆª',
                            type: 'select',
                            proxies: ['REJECT', 'ğŸ¯ å…¨çƒç›´è¿']
                        },
                        {
                            name: 'ğŸƒ åº”ç”¨å‡€åŒ–',
                            type: 'select',
                            proxies: ['REJECT', 'ğŸ¯ å…¨çƒç›´è¿']
                        },
                        {
                             name: 'ğŸŒ å›½å¤–åª’ä½“',
                             type: 'select',
                             proxies: ['ğŸš€ èŠ‚ç‚¹é€‰æ‹©', 'â™»ï¸ è‡ªåŠ¨é€‰æ‹©', 'ğŸ¯ å…¨çƒç›´è¿', 'ğŸ‡­ğŸ‡° é¦™æ¸¯èŠ‚ç‚¹', 'ğŸ‡¯ğŸ‡µ æ—¥æœ¬èŠ‚ç‚¹', 'ğŸ‡ºğŸ‡² ç¾å›½èŠ‚ç‚¹', 'ğŸ‡¸ğŸ‡¬ ç‹®åŸèŠ‚ç‚¹', 'ğŸ‡°ğŸ‡· éŸ©å›½èŠ‚ç‚¹', 'ğŸš© å…¶å®ƒèŠ‚ç‚¹']
                         },
                         {
                            name: 'ğŸ“² ç”µæŠ¥ä¿¡æ¯',
                            type: 'select',
                            proxies: ['ğŸš€ èŠ‚ç‚¹é€‰æ‹©', 'ğŸ¯ å…¨çƒç›´è¿', 'ğŸ‡­ğŸ‡° é¦™æ¸¯èŠ‚ç‚¹', 'ğŸ‡¯ğŸ‡µ æ—¥æœ¬èŠ‚ç‚¹', 'ğŸ‡ºğŸ‡² ç¾å›½èŠ‚ç‚¹', 'ğŸ‡¸ğŸ‡¬ ç‹®åŸèŠ‚ç‚¹', 'ğŸ‡°ğŸ‡· éŸ©å›½èŠ‚ç‚¹', 'ğŸš© å…¶å®ƒèŠ‚ç‚¹']
                        },
                        {
                            name: 'â“‚ï¸ å¾®è½¯æœåŠ¡',
                            type: 'select',
                            proxies: ['ğŸ¯ å…¨çƒç›´è¿', 'ğŸš€ èŠ‚ç‚¹é€‰æ‹©', 'ğŸ‡­ğŸ‡° é¦™æ¸¯èŠ‚ç‚¹', 'ğŸ‡¯ğŸ‡µ æ—¥æœ¬èŠ‚ç‚¹', 'ğŸ‡ºğŸ‡² ç¾å›½èŠ‚ç‚¹', 'ğŸ‡¸ğŸ‡¬ ç‹®åŸèŠ‚ç‚¹', 'ğŸ‡°ğŸ‡· éŸ©å›½èŠ‚ç‚¹', 'ğŸš© å…¶å®ƒèŠ‚ç‚¹']
                        },
                        {
                            name: 'ğŸ è‹¹æœæœåŠ¡',
                            type: 'select',
                            proxies: ['ğŸš€ èŠ‚ç‚¹é€‰æ‹©', 'ğŸ¯ å…¨çƒç›´è¿', 'ğŸ‡­ğŸ‡° é¦™æ¸¯èŠ‚ç‚¹', 'ğŸ‡¯ğŸ‡µ æ—¥æœ¬èŠ‚ç‚¹', 'ğŸ‡ºğŸ‡² ç¾å›½èŠ‚ç‚¹', 'ğŸ‡¸ğŸ‡¬ ç‹®åŸèŠ‚ç‚¹', 'ğŸ‡°ğŸ‡· éŸ©å›½èŠ‚ç‚¹', 'ğŸš© å…¶å®ƒèŠ‚ç‚¹']
                        },
                        {
                            name: 'ğŸ‡­ğŸ‡° é¦™æ¸¯èŠ‚ç‚¹',
                            type: 'url-test',
                            proxies: proxyNames.filter(name => name.includes('é¦™æ¸¯') || name.includes('HK') || name.includes('Hong')),
                            url: 'http://www.gstatic.com/generate_204',
                            interval: 300,
                            tolerance: 50
                        },
                        {
                            name: 'ğŸ‡¯ğŸ‡µ æ—¥æœ¬èŠ‚ç‚¹',
                            type: 'url-test',
                            proxies: proxyNames.filter(name => name.includes('æ—¥æœ¬') || name.includes('JP') || name.includes('Japan')),
                            url: 'http://www.gstatic.com/generate_204',
                            interval: 300,
                            tolerance: 50
                        },
                        {
                            name: 'ğŸ‡ºğŸ‡² ç¾å›½èŠ‚ç‚¹',
                            type: 'url-test',
                            proxies: proxyNames.filter(name => name.includes('ç¾å›½') || name.includes('US') || name.includes('United')),
                            url: 'http://www.gstatic.com/generate_204',
                            interval: 300,
                            tolerance: 50
                        },
                        {
                            name: 'ğŸ‡¸ğŸ‡¬ ç‹®åŸèŠ‚ç‚¹',
                            type: 'url-test',
                            proxies: proxyNames.filter(name => name.includes('æ–°åŠ å¡') || name.includes('ç‹®åŸ') || name.includes('SG') || name.includes('Singapore')),
                            url: 'http://www.gstatic.com/generate_204',
                            interval: 300,
                            tolerance: 50
                        },
                        {
                            name: 'ğŸ‡°ğŸ‡· éŸ©å›½èŠ‚ç‚¹',
                            type: 'url-test',
                            proxies: proxyNames.filter(name => name.includes('éŸ©å›½') || name.includes('KR') || name.includes('Korea')),
                            url: 'http://www.gstatic.com/generate_204',
                            interval: 300,
                            tolerance: 50
                        },
                        {
                            name: 'ğŸš© å…¶å®ƒèŠ‚ç‚¹',
                            type: 'select',
                            proxies: proxyNames.filter(name => 
                                !name.includes('é¦™æ¸¯') && !name.includes('HK') && !name.includes('Hong') &&
                                !name.includes('æ—¥æœ¬') && !name.includes('JP') && !name.includes('Japan') &&
                                !name.includes('ç¾å›½') && !name.includes('US') && !name.includes('United') &&
                                !name.includes('æ–°åŠ å¡') && !name.includes('ç‹®åŸ') && !name.includes('SG') && !name.includes('Singapore') &&
                                !name.includes('éŸ©å›½') && !name.includes('KR') && !name.includes('Korea')
                            )
                        },
                        {
                            name: 'ğŸ¯ å…¨çƒç›´è¿',
                            type: 'select',
                            proxies: ['DIRECT', 'ğŸš€ èŠ‚ç‚¹é€‰æ‹©']
                        },
                        {
                            name: 'ğŸ›‘ å…¨çƒæ‹¦æˆª',
                            type: 'select',
                            proxies: ['REJECT', 'DIRECT']
                        },
                        {
                            name: 'ğŸƒ åº”ç”¨å‡€åŒ–',
                            type: 'select',
                            proxies: ['REJECT', 'DIRECT']
                        },
                        {
                            name: 'ğŸŸ æ¼ç½‘ä¹‹é±¼',
                            type: 'select',
                            proxies: ['ğŸš€ èŠ‚ç‚¹é€‰æ‹©', 'ğŸ¯ å…¨çƒç›´è¿', 'â™»ï¸ è‡ªåŠ¨é€‰æ‹©', 'ğŸ‡­ğŸ‡° é¦™æ¸¯èŠ‚ç‚¹', 'ğŸ‡¯ğŸ‡µ æ—¥æœ¬èŠ‚ç‚¹', 'ğŸ‡ºğŸ‡² ç¾å›½èŠ‚ç‚¹', 'ğŸ‡¸ğŸ‡¬ ç‹®åŸèŠ‚ç‚¹', 'ğŸ‡°ğŸ‡· éŸ©å›½èŠ‚ç‚¹', 'ğŸš© å…¶å®ƒèŠ‚ç‚¹']
                        }
                    ].filter(group => {
                        // è¿‡æ»¤æ‰æ²¡æœ‰èŠ‚ç‚¹çš„åœ°åŒºç»„
                        if (['ğŸ‡­ğŸ‡° é¦™æ¸¯èŠ‚ç‚¹', 'ğŸ‡¯ğŸ‡µ æ—¥æœ¬èŠ‚ç‚¹', 'ğŸ‡ºğŸ‡² ç¾å›½èŠ‚ç‚¹', 'ğŸ‡¸ğŸ‡¬ ç‹®åŸèŠ‚ç‚¹', 'ğŸ‡°ğŸ‡· éŸ©å›½èŠ‚ç‚¹', 'ğŸš© å…¶å®ƒèŠ‚ç‚¹'].includes(group.name)) {
                            return group.proxies && group.proxies.length > 0;
                        }
                        return true;
                    }),
                    rules: [
                         // æœ¬åœ°ç½‘ç»œç›´è¿
                         'DOMAIN-SUFFIX,acl4.ssr,ğŸ¯ å…¨çƒç›´è¿',
                         'DOMAIN-SUFFIX,ip6-localhost,ğŸ¯ å…¨çƒç›´è¿',
                         'DOMAIN-SUFFIX,ip6-loopback,ğŸ¯ å…¨çƒç›´è¿',
                         'DOMAIN-SUFFIX,lan,ğŸ¯ å…¨çƒç›´è¿',
                         'DOMAIN-SUFFIX,local,ğŸ¯ å…¨çƒç›´è¿',
                         'DOMAIN-SUFFIX,localhost,ğŸ¯ å…¨çƒç›´è¿',
                         'IP-CIDR,0.0.0.0/8,ğŸ¯ å…¨çƒç›´è¿,no-resolve',
                         'IP-CIDR,10.0.0.0/8,ğŸ¯ å…¨çƒç›´è¿,no-resolve',
                         'IP-CIDR,100.64.0.0/10,ğŸ¯ å…¨çƒç›´è¿,no-resolve',
                         'IP-CIDR,127.0.0.0/8,ğŸ¯ å…¨çƒç›´è¿,no-resolve',
                         'IP-CIDR,172.16.0.0/12,ğŸ¯ å…¨çƒç›´è¿,no-resolve',
                         'IP-CIDR,192.168.0.0/16,ğŸ¯ å…¨çƒç›´è¿,no-resolve',
                         'IP-CIDR,198.18.0.0/16,ğŸ¯ å…¨çƒç›´è¿,no-resolve',
                         'IP-CIDR,224.0.0.0/4,ğŸ¯ å…¨çƒç›´è¿,no-resolve',
                         'IP-CIDR6,::1/128,ğŸ¯ å…¨çƒç›´è¿,no-resolve',
                         'IP-CIDR6,fc00::/7,ğŸ¯ å…¨çƒç›´è¿,no-resolve',
                         'IP-CIDR6,fe80::/10,ğŸ¯ å…¨çƒç›´è¿,no-resolve',
                         'IP-CIDR6,fd00::/8,ğŸ¯ å…¨çƒç›´è¿,no-resolve',
                         
                         // åº”ç”¨å‡€åŒ–
                         'DOMAIN,safebrowsing.urlsec.qq.com,ğŸƒ åº”ç”¨å‡€åŒ–',
                         'DOMAIN,safebrowsing.googleapis.com,ğŸƒ åº”ç”¨å‡€åŒ–',
                         'DOMAIN-SUFFIX,doubleclick.net,ğŸƒ åº”ç”¨å‡€åŒ–',
                         'DOMAIN-SUFFIX,googleadservices.com,ğŸƒ åº”ç”¨å‡€åŒ–',
                         'DOMAIN-SUFFIX,googlesyndication.com,ğŸƒ åº”ç”¨å‡€åŒ–',
                         'DOMAIN-SUFFIX,googletagservices.com,ğŸƒ åº”ç”¨å‡€åŒ–',
                         
                         // å…¨çƒæ‹¦æˆª
                         'DOMAIN-SUFFIX,ads.yahoo.com,ğŸ›‘ å…¨çƒæ‹¦æˆª',
                         'DOMAIN-SUFFIX,facebook.com,ğŸ›‘ å…¨çƒæ‹¦æˆª',
                         'DOMAIN-SUFFIX,googlevideo.com,ğŸ›‘ å…¨çƒæ‹¦æˆª',
                         
                         // ç”µæŠ¥ä¿¡æ¯
                         'DOMAIN-SUFFIX,t.me,ğŸ“² ç”µæŠ¥ä¿¡æ¯',
                         'DOMAIN-SUFFIX,tdesktop.com,ğŸ“² ç”µæŠ¥ä¿¡æ¯',
                         'DOMAIN-SUFFIX,telegra.ph,ğŸ“² ç”µæŠ¥ä¿¡æ¯',
                         'DOMAIN-SUFFIX,telegram.me,ğŸ“² ç”µæŠ¥ä¿¡æ¯',
                         'DOMAIN-SUFFIX,telegram.org,ğŸ“² ç”µæŠ¥ä¿¡æ¯',
                         'DOMAIN-SUFFIX,telesco.pe,ğŸ“² ç”µæŠ¥ä¿¡æ¯',
                         'IP-CIDR,91.108.4.0/22,ğŸ“² ç”µæŠ¥ä¿¡æ¯,no-resolve',
                         'IP-CIDR,91.108.8.0/22,ğŸ“² ç”µæŠ¥ä¿¡æ¯,no-resolve',
                         'IP-CIDR,91.108.12.0/22,ğŸ“² ç”µæŠ¥ä¿¡æ¯,no-resolve',
                         'IP-CIDR,91.108.16.0/22,ğŸ“² ç”µæŠ¥ä¿¡æ¯,no-resolve',
                         'IP-CIDR,91.108.56.0/22,ğŸ“² ç”µæŠ¥ä¿¡æ¯,no-resolve',
                         'IP-CIDR,149.154.160.0/20,ğŸ“² ç”µæŠ¥ä¿¡æ¯,no-resolve',
                         
                         // å›½å¤–åª’ä½“
                         'DOMAIN-SUFFIX,netflix.com,ğŸŒ å›½å¤–åª’ä½“',
                         'DOMAIN-SUFFIX,youtube.com,ğŸŒ å›½å¤–åª’ä½“',
                         'DOMAIN-SUFFIX,googlevideo.com,ğŸŒ å›½å¤–åª’ä½“',
                         'DOMAIN-SUFFIX,twitter.com,ğŸŒ å›½å¤–åª’ä½“',
                         'DOMAIN-SUFFIX,instagram.com,ğŸŒ å›½å¤–åª’ä½“',
                         'DOMAIN-SUFFIX,facebook.com,ğŸŒ å›½å¤–åª’ä½“',
                         
                         // è‹¹æœæœåŠ¡
                         'DOMAIN,testflight.apple.com,ğŸ è‹¹æœæœåŠ¡',
                         'DOMAIN-SUFFIX,apple.com,ğŸ è‹¹æœæœåŠ¡',
                         'DOMAIN-SUFFIX,icloud.com,ğŸ è‹¹æœæœåŠ¡',
                         'DOMAIN-SUFFIX,itunes.com,ğŸ è‹¹æœæœåŠ¡',
                         'DOMAIN-SUFFIX,me.com,ğŸ è‹¹æœæœåŠ¡',
                         
                         // å¾®è½¯æœåŠ¡
                         'DOMAIN-SUFFIX,live.com,â“‚ï¸ å¾®è½¯æœåŠ¡',
                         'DOMAIN-SUFFIX,microsoft.com,â“‚ï¸ å¾®è½¯æœåŠ¡',
                         'DOMAIN-SUFFIX,office.com,â“‚ï¸ å¾®è½¯æœåŠ¡',
                         'DOMAIN-SUFFIX,outlook.com,â“‚ï¸ å¾®è½¯æœåŠ¡',
                         'DOMAIN-SUFFIX,skype.com,â“‚ï¸ å¾®è½¯æœåŠ¡',
                         'DOMAIN-SUFFIX,windows.com,â“‚ï¸ å¾®è½¯æœåŠ¡',
                         
                         // è·¯ç”±å™¨ç®¡ç†ç•Œé¢
                         'DOMAIN,instant.arubanetworks.com,ğŸ¯ å…¨çƒç›´è¿',
                         'DOMAIN,setmeup.arubanetworks.com,ğŸ¯ å…¨çƒç›´è¿',
                         'DOMAIN,router.asus.com,ğŸ¯ å…¨çƒç›´è¿',
                         'DOMAIN,www.asusrouter.com,ğŸ¯ å…¨çƒç›´è¿',
                         'DOMAIN-SUFFIX,hiwifi.com,ğŸ¯ å…¨çƒç›´è¿',
                         'DOMAIN-SUFFIX,leike.cc,ğŸ¯ å…¨çƒç›´è¿',
                         'DOMAIN-SUFFIX,miwifi.com,ğŸ¯ å…¨çƒç›´è¿',
                         'DOMAIN-SUFFIX,tendawifi.com,ğŸ¯ å…¨çƒç›´è¿',
                         'DOMAIN-SUFFIX,zte.com.cn,ğŸ¯ å…¨çƒç›´è¿',
                         
                         // ä¸­å›½ç›´è¿
                         'DOMAIN-SUFFIX,cn,ğŸ¯ å…¨çƒç›´è¿',
                         'DOMAIN-KEYWORD,-cn,ğŸ¯ å…¨çƒç›´è¿',
                         'GEOIP,CN,ğŸ¯ å…¨çƒç›´è¿',
                         
                         // æœ€ç»ˆè§„åˆ™
                         'MATCH,ğŸŸ æ¼ç½‘ä¹‹é±¼'
                     ]
                };
                
                return config;
            }
            
            // æ ¼å¼åŒ–è¾“å‡º
            static formatOutput(config, format = 'json') {
                if (format === 'yaml') {
                    return ClashGenerator.toYaml(config);
                } else {
                    return JSON.stringify(config, null, 2);
                }
            }
            
            static toYaml(obj, indent = 0) {
                if (!obj || typeof obj !== 'object') {
                    return '';
                }
                
                const now = new Date();
                const timestamp = now.getFullYear() + '-' + 
                    String(now.getMonth() + 1).padStart(2, '0') + '-' + 
                    String(now.getDate()).padStart(2, '0') + ' ' +
                    String(now.getHours()).padStart(2, '0') + ':' +
                    String(now.getMinutes()).padStart(2, '0') + ':' +
                    String(now.getSeconds()).padStart(2, '0');
                
                const proxyCount = (obj.proxies && Array.isArray(obj.proxies)) ? obj.proxies.length : 0;
                let yaml = `#\n#-------------------------------------------------------------#\n#  åˆ›å»ºè€…ï¼š \`https://v2rayse.com\`\n#  åˆ›å»ºæ—¶é—´ï¼š${timestamp}\n#  æ¨¡ç‰ˆï¼šACL4SSR_NoAuto\n#  èŠ‚ç‚¹æ•°é‡ï¼š${proxyCount}\n#-------------------------------------------------------------#\n#\n`;
                
                const spaces = '  '.repeat(indent);
                
                for (const [key, value] of Object.entries(obj)) {
                    if (key === 'proxies' && Array.isArray(value)) {
                        yaml += `${spaces}${key}:\n`;
                        for (const proxy of value) {
                            yaml += `${spaces}  - name: "${proxy.name || 'Unknown'}"\n`;
                            yaml += `${spaces}    type: ${proxy.type || 'ss'}\n`;
                            yaml += `${spaces}    server: ${proxy.server || 'localhost'}\n`;
                            yaml += `${spaces}    port: ${proxy.port || 8080}\n`;
                            
                            // æ ¹æ®ä»£ç†ç±»å‹æ·»åŠ ç‰¹å®šå­—æ®µ
                            for (const [proxyKey, proxyValue] of Object.entries(proxy)) {
                                if (!['name', 'type', 'server', 'port'].includes(proxyKey)) {
                                    if (typeof proxyValue === 'object' && proxyValue !== null) {
                                        yaml += `${spaces}    ${proxyKey}:\n`;
                                        yaml += ClashGenerator.objectToYaml(proxyValue, indent + 3);
                                    } else if (typeof proxyValue === 'boolean') {
                                        yaml += `${spaces}    ${proxyKey}: ${proxyValue}\n`;
                                    } else if (proxyValue !== undefined && proxyValue !== null) {
                                        yaml += `${spaces}    ${proxyKey}: ${proxyValue}\n`;
                                    }
                                }
                            }
                        }
                    } else if (Array.isArray(value)) {
                        yaml += `${spaces}${key}:\n`;
                        for (const item of value) {
                            if (typeof item === 'object' && item !== null) {
                                yaml += `${spaces}  - `;
                                const itemYaml = ClashGenerator.objectToYaml(item, 0);
                                const lines = itemYaml.split('\n');
                                yaml += lines[0] + '\n';
                                for (let i = 1; i < lines.length; i++) {
                                    if (lines[i].trim()) {
                                        yaml += `${spaces}    ${lines[i]}\n`;
                                    }
                                }
                            } else {
                                yaml += `${spaces}  - ${item}\n`;
                            }
                        }
                    } else if (typeof value === 'object' && value !== null) {
                        yaml += `${spaces}${key}:\n`;
                        yaml += ClashGenerator.toYaml(value, indent + 1);
                    } else if (value !== undefined && value !== null) {
                        yaml += `${spaces}${key}: ${value}\n`;
                    }
                }
                
                return yaml;
            }
            
            static objectToYaml(obj, indent = 0) {
                if (!obj || typeof obj !== 'object') {
                    return '';
                }
                
                const spaces = '  '.repeat(indent);
                let result = '';
                
                for (const [key, value] of Object.entries(obj)) {
                    if (Array.isArray(value)) {
                        result += `${spaces}${key}:\n`;
                        for (const item of value) {
                            if (typeof item === 'object' && item !== null) {
                                result += `${spaces}  - `;
                                const itemLines = ClashGenerator.objectToYaml(item, 0).split('\n');
                                result += itemLines[0] + '\n';
                                for (let i = 1; i < itemLines.length; i++) {
                                    if (itemLines[i].trim()) {
                                        result += `${spaces}    ${itemLines[i]}\n`;
                                    }
                                }
                            } else {
                                result += `${spaces}  - ${item}\n`;
                            }
                        }
                    } else if (typeof value === 'object' && value !== null) {
                        result += `${spaces}${key}:\n`;
                        result += ClashGenerator.objectToYaml(value, indent + 1);
                    } else if (value !== undefined && value !== null) {
                        if (typeof value === 'string' && (value.includes(' ') || value.includes(':') || value.includes('#'))) {
                            result += `${spaces}${key}: "${value}"\n`;
                        } else {
                            result += `${spaces}${key}: ${value}\n`;
                        }
                    }
                }
                
                return result.trim();
            }
        }
        
        // èŠ‚ç‚¹é“¾æ¥ç”Ÿæˆå™¨
        class NodeGenerator {
            static generateShadowsocks(proxy) {
                const auth = btoa(`${proxy.cipher}:${proxy.password}`);
                const name = encodeURIComponent(proxy.name);
                return `ss://${auth}@${proxy.server}:${proxy.port}#${name}`;
            }
            
            static generateVmess(proxy) {
                const config = {
                    v: '2',
                    ps: proxy.name,
                    add: proxy.server,
                    port: proxy.port.toString(),
                    id: proxy.uuid,
                    aid: (proxy.alterId || 0).toString(),
                    net: proxy.network || 'tcp',
                    type: 'none',
                    host: proxy['ws-opts']?.headers?.Host || '',
                    path: proxy['ws-opts']?.path || '/',
                    tls: proxy.tls ? 'tls' : ''
                };
                return 'vmess://' + btoa(JSON.stringify(config));
            }
            
            static generateTrojan(proxy) {
                const name = encodeURIComponent(proxy.name);
                let url = `trojan://${proxy.password}@${proxy.server}:${proxy.port}`;
                const params = new URLSearchParams();
                if (proxy.sni && proxy.sni !== proxy.server) {
                    params.set('sni', proxy.sni);
                }
                if (proxy['skip-cert-verify']) {
                    params.set('allowInsecure', '1');
                }
                if (params.toString()) {
                    url += '?' + params.toString();
                }
                url += '#' + name;
                return url;
            }
            
            static generateVless(proxy) {
                const name = encodeURIComponent(proxy.name);
                let url = `vless://${proxy.uuid}@${proxy.server}:${proxy.port}`;
                const params = new URLSearchParams();
                if (proxy.flow) {
                    params.set('flow', proxy.flow);
                }
                if (proxy.network && proxy.network !== 'tcp') {
                    params.set('type', proxy.network);
                }
                if (proxy.tls) {
                    params.set('security', 'tls');
                }
                if (params.toString()) {
                    url += '?' + params.toString();
                }
                url += '#' + name;
                return url;
            }
            
            static generateSocks5(proxy) {
                const name = encodeURIComponent(proxy.name);
                let url = 'socks5://';
                if (proxy.username && proxy.password) {
                    url += `${proxy.username}:${proxy.password}@`;
                }
                url += `${proxy.server}:${proxy.port}#${name}`;
                return url;
            }
            
            static generateHttp(proxy) {
                const name = encodeURIComponent(proxy.name);
                let url = 'http://';
                if (proxy.username && proxy.password) {
                    url += `${proxy.username}:${proxy.password}@`;
                }
                url += `${proxy.server}:${proxy.port}#${name}`;
                return url;
            }
            
            static generateSsr(proxy) {
                const serverInfo = `${proxy.server}:${proxy.port}:${proxy.protocol}:${proxy.cipher}:${proxy.obfs}:${btoa(proxy.password)}`;
                const params = new URLSearchParams();
                params.set('remarks', btoa(proxy.name));
                const data = serverInfo + '/?' + params.toString();
                return 'ssr://' + btoa(data);
            }
            
            static generateHysteria(proxy) {
                const name = encodeURIComponent(proxy.name);
                const params = new URLSearchParams();
                params.set('protocol', proxy.protocol || 'udp');
                params.set('auth', proxy.auth_str || '');
                params.set('peer', proxy.sni || proxy.server);
                params.set('insecure', proxy['skip-cert-verify'] ? '1' : '0');
                params.set('upmbps', proxy.up || '50');
                params.set('downmbps', proxy.down || '250');
                params.set('alpn', proxy.alpn || 'h3');
                
                return `hysteria://${proxy.server}:${proxy.port}?${params.toString()}#${name}`;
            }
            
            static generateHysteria2(proxy) {
                const name = encodeURIComponent(proxy.name);
                const params = new URLSearchParams();
                params.set('sni', proxy.sni || proxy.server);
                params.set('insecure', proxy['skip-cert-verify'] ? '1' : '0');
                if (proxy.mport) {
                    params.set('mport', proxy.mport);
                }
                
                return `hysteria2://${proxy.password}@${proxy.server}:${proxy.port}?${params.toString()}#${name}`;
            }
        }
        
        // ä¸»è½¬æ¢å™¨
        class Converter {
            static nodeToClash(nodeUrls) {
                const proxies = [];
                const urls = nodeUrls.split('\n').filter(url => url.trim());
                let counter = 1;
                
                for (const url of urls) {
                    const trimmedUrl = url.trim();
                    let proxy = null;
                    
                    if (trimmedUrl.startsWith('ss://')) {
                        proxy = ProtocolParser.parseShadowsocks(trimmedUrl);
                    } else if (trimmedUrl.startsWith('ssr://')) {
                        proxy = ProtocolParser.parseSsr(trimmedUrl);
                    } else if (trimmedUrl.startsWith('vmess://')) {
                        proxy = ProtocolParser.parseVmess(trimmedUrl);
                    } else if (trimmedUrl.startsWith('trojan://')) {
                        proxy = ProtocolParser.parseTrojan(trimmedUrl);
                    } else if (trimmedUrl.startsWith('vless://')) {
                        proxy = ProtocolParser.parseVless(trimmedUrl);
                    } else if (trimmedUrl.startsWith('socks5://')) {
                        proxy = ProtocolParser.parseSocks5(trimmedUrl);
                    } else if (trimmedUrl.startsWith('hysteria://')) {
                        proxy = ProtocolParser.parseHysteria(trimmedUrl);
                    } else if (trimmedUrl.startsWith('hysteria2://')) {
                        proxy = ProtocolParser.parseHysteria2(trimmedUrl);
                    } else if (trimmedUrl.includes('t.me/socks')) {
                        proxy = ProtocolParser.parseTelegram(trimmedUrl);
                    } else if (trimmedUrl.startsWith('http://') || trimmedUrl.startsWith('https://') || trimmedUrl.includes('`http')) {
                        proxy = ProtocolParser.parseHttp(trimmedUrl);
                    }
                    
                    if (proxy) {
                        // ä¸ºèŠ‚ç‚¹æ·»åŠ åºå·åç¼€
                        if (proxy.name === 'v2rayse_test' || proxy.name.includes('v2rayse_test')) {
                            proxy.name = `v2rayse_test_${counter}`;
                            counter++;
                        }
                        
                        // ç¡®ä¿åç§°å”¯ä¸€
                        let finalName = proxy.name;
                        let nameCounter = 1;
                        while (proxies.some(p => p.name === finalName)) {
                            nameCounter++;
                            finalName = `${proxy.name}_${nameCounter}`;
                        }
                        proxy.name = finalName;
                        
                        // æ·»åŠ å¿…è¦çš„å­—æ®µ
                        if (proxy.type === 'trojan' || proxy.type === 'vless' || proxy.type === 'hysteria' || proxy.type === 'hysteria2') {
                            proxy.udp = true;
                            proxy['skip-cert-verify'] = true;
                        }
                        if (proxy.type === 'http' || proxy.type === 'socks5') {
                            proxy.udp = true;
                        }
                        if (proxy.type === 'hysteria') {
                            proxy.recv_window = 104857600;
                            proxy.recv_window_conn = 26214400;
                            proxy.disable_mtu_discovery = true;
                        }
                        if (proxy.type === 'hysteria2') {
                            // Hysteria2ç‰¹æœ‰å­—æ®µå·²åœ¨parseHysteria2ä¸­è®¾ç½®
                        }
                        
                        proxies.push(proxy);
                    }
                }
                
                if (proxies.length === 0) {
                    throw new Error('æœªæ‰¾åˆ°æœ‰æ•ˆçš„èŠ‚ç‚¹é“¾æ¥');
                }
                
                return ClashGenerator.generateConfig(proxies);
            }
            
            static clashToNode(clashConfig) {
                try {
                    const config = typeof clashConfig === 'string' ? JSON.parse(clashConfig) : clashConfig;
                    const proxies = config.proxies || config.Proxy || [];
                    const nodeUrls = [];
                    
                    for (const proxy of proxies) {
                        let url = null;
                        
                        switch (proxy.type) {
                            case 'ss':
                                url = NodeGenerator.generateShadowsocks(proxy);
                                break;
                            case 'ssr':
                                url = NodeGenerator.generateSsr(proxy);
                                break;
                            case 'vmess':
                                url = NodeGenerator.generateVmess(proxy);
                                break;
                            case 'trojan':
                                url = NodeGenerator.generateTrojan(proxy);
                                break;
                            case 'vless':
                                url = NodeGenerator.generateVless(proxy);
                                break;
                            case 'socks5':
                                url = NodeGenerator.generateSocks5(proxy);
                                break;
                            case 'http':
                                url = NodeGenerator.generateHttp(proxy);
                                break;
                            case 'hysteria':
                                url = NodeGenerator.generateHysteria(proxy);
                                break;
                            case 'hysteria2':
                                url = NodeGenerator.generateHysteria2(proxy);
                                break;
                        }
                        
                        if (url) {
                            nodeUrls.push(url);
                        }
                    }
                    
                    if (nodeUrls.length === 0) {
                        throw new Error('æœªæ‰¾åˆ°æœ‰æ•ˆçš„ä»£ç†é…ç½®');
                    }
                    
                    return nodeUrls.join('\n');
                } catch (e) {
                    throw new Error('Clashé…ç½®æ ¼å¼é”™è¯¯: ' + e.message);
                }
            }
        }
        
        // UIæ§åˆ¶å™¨
        class UIController {
            constructor() {
                this.inputType = document.getElementById('inputType');
                this.outputType = document.getElementById('outputType');
                this.inputArea = document.getElementById('inputArea');
                this.outputArea = document.getElementById('outputArea');
                this.convertBtn = document.getElementById('convertBtn');
                this.copyBtn = document.getElementById('copyBtn');
                this.inputError = document.getElementById('inputError');
                this.outputSuccess = document.getElementById('outputSuccess');
                
                this.bindEvents();
            }
            
            bindEvents() {
                this.convertBtn.addEventListener('click', () => this.convert());
                this.copyBtn.addEventListener('click', () => this.copyResult());
                
                this.inputType.addEventListener('change', () => {
                    this.outputType.value = this.inputType.value === 'node' ? 'clash' : 'node';
                    this.updatePlaceholders();
                });
                
                this.outputType.addEventListener('change', () => {
                    this.inputType.value = this.outputType.value === 'node' ? 'clash' : 'node';
                    this.updatePlaceholders();
                });
                
                this.inputArea.addEventListener('input', () => {
                    this.hideError();
                    this.hideSuccess();
                });
            }
            
            updatePlaceholders() {
                if (this.inputType.value === 'node') {
                    this.inputArea.placeholder = 'è¯·è¾“å…¥èŠ‚ç‚¹é“¾æ¥ï¼Œæ¯è¡Œä¸€ä¸ª...\n\nç¤ºä¾‹:\nss://YWVzLTI1Ni1nY206cGFzc3dvcmQ@192.168.1.1:8388#èŠ‚ç‚¹1\nvmess://eyJ2IjoiMiIsInBzIjoi...';
                } else {
                    this.inputArea.placeholder = 'è¯·è¾“å…¥Clashé…ç½®å†…å®¹...\n\nç¤ºä¾‹:\n{\n  "proxies": [\n    {\n      "name": "èŠ‚ç‚¹1",\n      "type": "ss",\n      "server": "192.168.1.1",\n      "port": 8388,\n      "cipher": "aes-256-gcm",\n      "password": "password"\n    }\n  ]\n}';
                }
            }
            
            convert() {
                const input = this.inputArea.value.trim();
                if (!input) {
                    this.showError('è¯·è¾“å…¥è¦è½¬æ¢çš„å†…å®¹');
                    return;
                }
                
                try {
                    let result;
                    
                    if (this.inputType.value === 'node') {
                         const clashConfig = Converter.nodeToClash(input);
                         result = ClashGenerator.formatOutput(clashConfig, 'yaml');
                     } else {
                         result = Converter.clashToNode(input);
                     }
                    
                    this.outputArea.value = result;
                    this.copyBtn.style.display = 'inline-block';
                    this.hideError();
                    this.showSuccess('è½¬æ¢æˆåŠŸï¼');
                } catch (error) {
                    this.showError(error.message);
                    this.outputArea.value = '';
                    this.copyBtn.style.display = 'none';
                }
            }
            
            copyResult() {
                this.outputArea.select();
                document.execCommand('copy');
                this.showSuccess('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼');
            }
            
            showError(message) {
                this.inputError.textContent = message;
                this.inputError.style.display = 'block';
            }
            
            hideError() {
                this.inputError.style.display = 'none';
            }
            
            showSuccess(message) {
                this.outputSuccess.textContent = message;
                this.outputSuccess.style.display = 'block';
                setTimeout(() => this.hideSuccess(), 3000);
            }
            
            hideSuccess() {
                this.outputSuccess.style.display = 'none';
            }
        }
        
        // åˆå§‹åŒ–åº”ç”¨
        document.addEventListener('DOMContentLoaded', () => {
            new UIController();
        });
    </script>
</body>
</html>